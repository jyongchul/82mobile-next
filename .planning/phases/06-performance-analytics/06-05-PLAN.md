---
wave: 3
depends_on: [06-02, 06-04]
files_modified:
  - components/layout/SmoothScroll.tsx
  - lib/hooks/useScrollNavigation.ts
  - app/[locale]/layout.tsx
autonomous: true
---

# Plan 06-05: Scroll Performance Optimization

## Objective

Optimize scroll performance to achieve consistent 60fps during smooth scroll navigation by implementing GPU acceleration, debouncing, and passive event listeners.

## Context

**Current State:**
- Lenis smooth scroll implemented (Phase 1)
- Intersection Observer for section tracking (Phase 1)
- Core Web Vitals monitoring in place (Plan 06-02)
- Mobile-first optimization complete (Phase 5)

**Performance Baseline (Phase 5):**
- Bundle sizes: 118-125KB (under 220KB target)
- Estimated LCP: 2.0-2.5s
- Touch targets: ≥44px (WCAG 2.1 AA)

**Phase 6 Target:**
- Consistent 60fps during scroll (no frame drops)
- Smooth scroll indicator performance
- No layout shifts during scroll
- Passive event listeners for better performance

## Tasks

<task id="1" name="Optimize Lenis smooth scroll configuration">

**Action:** Configure Lenis with optimal settings for 60fps performance

**Steps:**
1. Update `components/layout/SmoothScroll.tsx`:
   ```typescript
   'use client'

   import { useEffect, useRef } from 'react'
   import Lenis from '@studio-freight/lenis'

   export default function SmoothScroll({ children }: { children: React.ReactNode }) {
     const lenisRef = useRef<Lenis | null>(null)

     useEffect(() => {
       // Initialize Lenis with performance-optimized settings
       const lenis = new Lenis({
         duration: 1.2,
         easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
         orientation: 'vertical',
         gestureOrientation: 'vertical',
         smoothWheel: true,
         wheelMultiplier: 1,
         smoothTouch: false, // Disable on touch for better native performance
         touchMultiplier: 2,
         infinite: false,
         // Performance optimizations
         autoResize: true,
         // Use RAF for smooth 60fps
       })

       lenisRef.current = lenis

       // Request Animation Frame loop
       function raf(time: number) {
         lenis.raf(time)
         requestAnimationFrame(raf)
       }

       requestAnimationFrame(raf)

       return () => {
         lenis.destroy()
       }
     }, [])

     return <>{children}</>
   }
   ```

2. Ensure smooth scroll is GPU-accelerated:
   ```css
   /* Add to globals.css if not present */
   html.lenis {
     height: auto;
   }

   .lenis.lenis-smooth {
     scroll-behavior: auto;
   }

   .lenis.lenis-smooth [data-lenis-prevent] {
     overscroll-behavior: contain;
   }

   .lenis.lenis-stopped {
     overflow: hidden;
   }

   .lenis.lenis-scrolling iframe {
     pointer-events: none;
   }

   /* GPU acceleration */
   [data-lenis-scroll] {
     will-change: transform;
     transform: translateZ(0);
   }
   ```

**Verification:**
- [ ] Lenis configured with optimal duration and easing
- [ ] RAF loop running smoothly
- [ ] GPU acceleration enabled (will-change, translateZ)
- [ ] Touch scroll uses native (smoothTouch: false)
- [ ] No JavaScript errors in console

</task>

<task id="2" name="Implement passive event listeners for scroll">

**Action:** Convert scroll event listeners to passive mode for better performance

**Steps:**
1. Update `lib/hooks/useScrollNavigation.ts`:
   ```typescript
   import { useEffect, useState, useCallback } from 'react'

   export function useScrollNavigation(sections: string[]) {
     const [activeSection, setActiveSection] = useState<string>('')

     useEffect(() => {
       // Passive scroll listener for better performance
       const handleScroll = () => {
         // Debounce using RAF for 60fps
         requestAnimationFrame(() => {
           // Section detection logic here
           const scrollPosition = window.scrollY + window.innerHeight / 2

           for (const section of sections) {
             const element = document.getElementById(section)
             if (!element) continue

             const { top, bottom } = element.getBoundingClientRect()
             const absoluteTop = top + window.scrollY
             const absoluteBottom = bottom + window.scrollY

             if (scrollPosition >= absoluteTop && scrollPosition < absoluteBottom) {
               setActiveSection(section)
               break
             }
           }
         })
       }

       // Add passive listener
       window.addEventListener('scroll', handleScroll, { passive: true })

       // Initial check
       handleScroll()

       return () => {
         window.removeEventListener('scroll', handleScroll)
       }
     }, [sections])

     return activeSection
   }
   ```

2. Verify all scroll listeners are passive:
   ```bash
   # Search for non-passive scroll listeners
   grep -r "addEventListener.*scroll" app/ components/ lib/ --include="*.ts" --include="*.tsx"
   ```

3. Update any remaining non-passive listeners to passive

**Verification:**
- [ ] Scroll event listener marked as passive
- [ ] RAF used for debouncing (60fps aligned)
- [ ] No forced synchronous layout (getBoundingClientRect cached)
- [ ] Chrome DevTools Performance shows no long tasks during scroll
- [ ] Lighthouse shows no passive listener warnings

</task>

<task id="3" name="Optimize scroll progress indicator">

**Action:** Ensure scroll progress bar doesn't cause layout thrashing

**Steps:**
1. Create optimized scroll progress component:
   ```typescript
   // components/ui/ScrollProgress.tsx
   'use client'

   import { useEffect, useState } from 'react'

   export default function ScrollProgress() {
     const [progress, setProgress] = useState(0)

     useEffect(() => {
       let rafId: number

       const updateProgress = () => {
         // Calculate progress
         const scrollHeight = document.documentElement.scrollHeight - window.innerHeight
         const scrolled = window.scrollY
         const progress = (scrolled / scrollHeight) * 100

         setProgress(progress)
       }

       const handleScroll = () => {
         // Use RAF to align with 60fps
         if (rafId) {
           cancelAnimationFrame(rafId)
         }
         rafId = requestAnimationFrame(updateProgress)
       }

       window.addEventListener('scroll', handleScroll, { passive: true })
       updateProgress() // Initial value

       return () => {
         window.removeEventListener('scroll', handleScroll)
         if (rafId) {
           cancelAnimationFrame(rafId)
         }
       }
     }, [])

     return (
       <div
         className="fixed top-0 left-0 h-1 bg-gradient-to-r from-blue-500 to-purple-500 z-50 transition-none"
         style={{
           width: `${progress}%`,
           transform: 'translateZ(0)', // GPU acceleration
           willChange: 'width',
         }}
       />
     )
   }
   ```

2. Add to layout if not present:
   ```typescript
   // app/[locale]/layout.tsx
   import ScrollProgress from '@/components/ui/ScrollProgress'

   export default function RootLayout({ children, params: { locale } }) {
     return (
       <html lang={locale}>
         <body>
           <ScrollProgress />
           {children}
         </body>
       </html>
     )
   }
   ```

**Verification:**
- [ ] Scroll progress uses RAF for updates
- [ ] GPU accelerated (transform: translateZ(0))
- [ ] will-change: width applied
- [ ] No layout thrashing (no getBoundingClientRect in loop)
- [ ] Smooth 60fps animation during scroll

</task>

<task id="4" name="Debounce Intersection Observer callbacks">

**Action:** Optimize Intersection Observer to avoid excessive callback executions

**Steps:**
1. Update Intersection Observer in `lib/hooks/useScrollNavigation.ts`:
   ```typescript
   useEffect(() => {
     const observerOptions = {
       root: null,
       rootMargin: '-50% 0px -50% 0px', // Center of viewport
       threshold: 0,
     }

     let rafId: number

     const observerCallback: IntersectionObserverCallback = (entries) => {
       // Use RAF to debounce and align with 60fps
       if (rafId) {
         cancelAnimationFrame(rafId)
       }

       rafId = requestAnimationFrame(() => {
         // Find the most visible section
         let maxRatio = 0
         let mostVisible = ''

         entries.forEach((entry) => {
           if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
             maxRatio = entry.intersectionRatio
             mostVisible = entry.target.id
           }
         })

         if (mostVisible) {
           setActiveSection(mostVisible)
         }
       })
     }

     const observer = new IntersectionObserver(observerCallback, observerOptions)

     sections.forEach((section) => {
       const element = document.getElementById(section)
       if (element) {
         observer.observe(element)
       }
     })

     return () => {
       observer.disconnect()
       if (rafId) {
         cancelAnimationFrame(rafId)
       }
     }
   }, [sections])
   ```

**Verification:**
- [ ] Intersection Observer callbacks debounced with RAF
- [ ] Only most visible section triggers state update
- [ ] No excessive re-renders
- [ ] Chrome DevTools Performance shows no long tasks from observer
- [ ] Section tracking still accurate

</task>

<task id="5" name="Verify 60fps performance">

**Action:** Use Chrome DevTools Performance to verify scroll performance

**Steps:**
1. Build production version:
   ```bash
   npm run build
   npm run start
   ```

2. Open Chrome DevTools → Performance tab

3. Record scroll performance:
   - Start recording
   - Scroll from top to bottom of page
   - Stop recording

4. Analyze results:
   - Check FPS counter (should be consistently 60fps)
   - Look for long tasks (>50ms) during scroll
   - Check for layout thrashing (forced reflow warnings)
   - Verify no dropped frames

5. Check Web Vitals:
   - CLS should remain <0.1 during scroll
   - INP should be <200ms for scroll interactions
   - No performance warnings in console

6. Document findings:
   ```markdown
   ## Scroll Performance Results

   **Test Date:** [DATE]
   **Browser:** Chrome [VERSION]
   **Device:** [Desktop/Mobile]

   ### FPS During Scroll
   - Average FPS: [XX]/60
   - Frame drops: [X] frames
   - Long tasks: [X] tasks >50ms

   ### Web Vitals (During Scroll)
   - CLS: [X.XXX] (<0.1 ✓/✗)
   - INP: [XXX]ms (<200ms ✓/✗)

   ### Chrome DevTools Issues
   - Layout thrashing: [Yes/No]
   - Non-passive listeners: [Count]
   - Forced reflows: [Count]

   ### Verdict
   - [ ] Consistent 60fps achieved
   - [ ] No frame drops during scroll
   - [ ] No layout shifts
   - [ ] All optimizations applied
   ```

**Verification:**
- [ ] Production build tested
- [ ] Chrome DevTools Performance recording analyzed
- [ ] FPS consistently at 60 (no drops)
- [ ] No long tasks during scroll
- [ ] No layout thrashing detected
- [ ] Web Vitals remain within targets during scroll
- [ ] Results documented in phase directory

</task>

## Verification Criteria

**Performance Requirements:**
- [ ] Consistent 60fps during scroll (Chrome DevTools confirms)
- [ ] No frame drops when scrolling from top to bottom
- [ ] No layout shifts during scroll (CLS <0.1)
- [ ] Scroll progress indicator smooth and GPU-accelerated
- [ ] All scroll event listeners are passive

**Code Quality:**
- [ ] Lenis configured with optimal settings
- [ ] RAF used for all scroll-based updates
- [ ] GPU acceleration applied (will-change, translateZ)
- [ ] No forced synchronous layout
- [ ] Intersection Observer debounced with RAF

**Web Vitals (During Scroll):**
- [ ] CLS remains <0.1
- [ ] INP <200ms for scroll interactions
- [ ] No performance warnings in console
- [ ] Lighthouse shows no scroll performance issues

## Must-Haves (Goal-Backward Verification)

From Phase 6 success criteria:

1. **Scroll Smooth:** Chrome DevTools Performance shows consistent 60fps during scroll
   - [ ] FPS counter shows 60fps throughout scroll
   - [ ] No frame drops detected
   - [ ] No long tasks (>50ms) during scroll
   - [ ] Performance recording saved as evidence

2. **Score Met:** Lighthouse Performance >85 (scroll performance contributes)
   - [ ] Scroll optimizations don't add to bundle size
   - [ ] Passive listeners eliminate warnings
   - [ ] GPU acceleration improves perceived performance

3. **Bundle Met:** Total Blocking Time <300ms
   - [ ] RAF debouncing prevents blocking main thread
   - [ ] Passive listeners reduce scroll latency
   - [ ] No synchronous layout calculations during scroll

## Notes

- Lenis `smoothTouch: false` uses native scroll on mobile for best performance
- RAF ensures all scroll updates align with 60fps refresh rate
- Passive event listeners allow browser to optimize scroll handling
- GPU acceleration (`transform: translateZ(0)`, `will-change`) offloads rendering
- Debouncing Intersection Observer prevents callback storms
- Chrome DevTools Performance is the source of truth for 60fps verification

## Dependencies

- Phase 1 complete (Lenis smooth scroll baseline)
- Plan 06-02 complete (Web Vitals monitoring to verify performance)
- Plan 06-04 complete (Image/font optimization to reduce load on scroll)

## Estimated Impact

**Performance Improvement:** Consistent 60fps (eliminates frame drops)
**Bundle Size:** +0KB (optimization only, no new libraries)
**CLS Reduction:** Prevents scroll-induced layout shifts
**Complexity:** Low (standard performance optimization patterns)
