---
wave: 3
depends_on: [04-02]
files_modified:
  - app/api/payment/initiate/route.ts
  - lib/payment/portone.ts
  - components/cart/CartDrawerCheckout.tsx
  - .env.local
autonomous: false
checkpoint: payment_credentials
---

# Plan 04-03: Payment Integration (PortOne/Eximbay)

## Objective

Integrate payment processing using PortOne SDK (which supports Eximbay) to enable actual credit card payments after order creation.

## Context

Plan 02 creates WooCommerce orders with 'pending' status. Now we need to initiate payment, handle success/failure callbacks, and update order status. The project already has `@portone/browser-sdk` installed.

**CHECKPOINT:** This plan requires customer-provided credentials (PORTONE_STORE_ID, PORTONE_CHANNEL_KEY or direct EXIMBAY_MID, EXIMBAY_SECRET_KEY). Execution pauses at checkpoint to confirm credentials are available.

## Tasks

<task id="checkpoint-credentials">
<description>Verify payment gateway credentials available</description>

**CHECKPOINT: Payment Credentials**

This plan requires one of:
- **Option A (Recommended):** PortOne credentials
  - `PORTONE_STORE_ID`
  - `PORTONE_CHANNEL_KEY`
- **Option B:** Direct Eximbay credentials
  - `EXIMBAY_MID` (Merchant ID)
  - `EXIMBAY_SECRET_KEY`

**Question for user:**
Which credentials does the customer have? Check with 권아담.

If PortOne credentials available → Continue with PortOne integration (simpler)
If only Eximbay credentials → Use direct Eximbay integration (more complex)
If neither → Pause plan execution, wait for customer signup

**Decision:**
- [ ] PortOne credentials available (continue)
- [ ] Eximbay credentials only (modify implementation)
- [ ] Neither available (pause, wait for customer)

Continue based on user response.
</task>

<task id="create-portone-lib">
<description>Create PortOne SDK initialization utility</description>

Create `lib/payment/portone.ts`:

```typescript
import * as PortOne from '@portone/browser-sdk/v2';

/**
 * Initialize PortOne payment request
 *
 * @param orderId - WooCommerce order ID
 * @param amount - Total amount in KRW (without decimal)
 * @param customerEmail - Customer email for receipt
 * @param customerName - Customer name for payment window
 */
export async function initiatePortOnePayment({
  orderId,
  amount,
  customerEmail,
  customerName
}: {
  orderId: number;
  amount: number;
  customerEmail: string;
  customerName: string;
}) {
  const storeId = process.env.NEXT_PUBLIC_PORTONE_STORE_ID!;
  const channelKey = process.env.NEXT_PUBLIC_PORTONE_CHANNEL_KEY!;

  if (!storeId || !channelKey) {
    throw new Error('PortOne credentials not configured');
  }

  try {
    const response = await PortOne.requestPayment({
      storeId,
      channelKey,
      paymentId: `order_${orderId}_${Date.now()}`, // Unique payment ID
      orderName: `82Mobile Order #${orderId}`,
      totalAmount: amount,
      currency: 'CURRENCY_KRW',
      payMethod: 'CARD', // Credit card only
      customer: {
        email: customerEmail,
        fullName: customerName
      },
      redirectUrl: `${window.location.origin}/order-complete?orderId=${orderId}`,
      // Webhook will be called automatically by PortOne
      noticeUrls: [`${process.env.NEXT_PUBLIC_BASE_URL}/api/payment/webhook`]
    });

    return response;
  } catch (error) {
    console.error('[PortOne] Payment initiation error:', error);
    throw error;
  }
}
```

Key decisions:
- `paymentId` includes timestamp for uniqueness across retries
- `payMethod: 'CARD'` restricts to credit cards (Visa, Mastercard, etc.)
- `redirectUrl` sends user to order confirmation page after payment
- `noticeUrls` registers webhook for server-side verification

Verification: TypeScript compilation passes
</task>

<task id="update-env-template">
<description>Add environment variables template</description>

Add to `.env.local.template` (or create if doesn't exist):

```bash
# PortOne Payment Gateway
NEXT_PUBLIC_PORTONE_STORE_ID=your_store_id_here
NEXT_PUBLIC_PORTONE_CHANNEL_KEY=your_channel_key_here
NEXT_PUBLIC_BASE_URL=http://localhost:3000

# Server-side payment verification
PORTONE_API_SECRET=your_api_secret_here
```

Add to `.gitignore` if not already:
```
.env.local
```

User must populate `.env.local` with actual credentials from customer.

Verification: `.env.local.template` exists with PortOne variables
</task>

<task id="wire-payment-to-form">
<description>Wire payment initiation to checkout form</description>

Update `components/cart/CartDrawerCheckout.tsx` to call payment after order creation:

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { checkoutSchema, CheckoutFormData, defaultCheckoutValues } from '@/lib/validation/checkout-schema';
import { useCartStore } from '@/stores/cart';
import { useUIStore } from '@/stores/ui';
import { useState } from 'react';
import { initiatePortOnePayment } from '@/lib/payment/portone';

export default function CartDrawerCheckout() {
  const items = useCartStore((state) => state.items);
  const clearCart = useCartStore((state) => state.clearCart);
  const closeCart = useUIStore((state) => state.closeCart);
  const [orderError, setOrderError] = useState<string | null>(null);

  const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const tax = Math.round(total * 0.1);
  const grandTotal = total + tax;

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<CheckoutFormData>({
    resolver: zodResolver(checkoutSchema),
    mode: 'onBlur',
    reValidateMode: 'onChange',
    defaultValues: defaultCheckoutValues
  });

  const onSubmit = async (data: CheckoutFormData) => {
    setOrderError(null);

    try {
      // Step 1: Create WooCommerce order
      const orderResponse = await fetch('/api/orders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          billing: {
            email: data.email,
            firstName: data.firstName,
            lastName: data.lastName,
            phone: data.phone,
            address1: data.address1 || '',
            city: data.city || '',
            postcode: data.postcode || '',
            country: data.country
          },
          items: items.map(item => ({
            id: item.productId,
            quantity: item.quantity
          })),
          paymentMethod: 'portone'
        })
      });

      if (!orderResponse.ok) {
        const error = await orderResponse.json();
        throw new Error(error.error || 'Failed to create order');
      }

      const order = await orderResponse.json();
      console.log('[Checkout] Order created:', order.orderId);

      // Step 2: Initiate payment
      const paymentResponse = await initiatePortOnePayment({
        orderId: order.orderId,
        amount: grandTotal,
        customerEmail: data.email,
        customerName: `${data.firstName} ${data.lastName}`
      });

      console.log('[Checkout] Payment response:', paymentResponse);

      // Check payment result
      if (paymentResponse?.code === 'FAILURE_TYPE_PG') {
        throw new Error(paymentResponse.message || 'Payment failed');
      }

      // Success: Clear cart and close drawer
      // Actual order status update will come via webhook
      clearCart();
      closeCart();

      // Redirect to order confirmation
      window.location.href = `/order-complete?orderId=${order.orderId}&paymentId=${paymentResponse?.paymentId}`;
    } catch (error: any) {
      console.error('[Checkout] Error:', error);
      setOrderError(error.message || 'Checkout failed. Please try again.');
    }
  };

  // Keep existing JSX
  return (
    <div className="flex flex-col h-full">
      {/* Error Display */}
      {orderError && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-lg mb-4">
          <p className="text-sm text-red-800 font-medium">Payment Error</p>
          <p className="text-sm text-red-700 mt-1">{orderError}</p>
          <button
            onClick={() => setOrderError(null)}
            className="text-sm text-red-600 underline mt-2"
          >
            Try again
          </button>
        </div>
      )}

      {/* ... existing form JSX ... */}
    </div>
  );
}
```

Key changes:
- Two-step process: Create order → Initiate payment
- `clearCart()` and `closeCart()` on payment success
- Redirect to `/order-complete` page with order ID
- Payment errors displayed with retry option

Verification:
- Form submission triggers payment window
- Payment window shows correct amount and order details
- Successful payment redirects to confirmation page
- Failed payment shows error message
</task>

<task id="update-payment-webhook">
<description>Update payment webhook for PortOne callback</description>

Update `app/api/payment/webhook/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import crypto from 'crypto';

/**
 * POST /api/payment/webhook
 * PortOne payment status webhook
 *
 * Called by PortOne after payment completion
 * Updates WooCommerce order status based on payment result
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { imp_uid, merchant_uid, status } = body;

    console.log('[Payment Webhook] Received:', { imp_uid, merchant_uid, status });

    // TODO: Verify webhook signature (PortOne provides verification method)
    // const signature = request.headers.get('portone-signature');
    // if (!verifySignature(signature, body)) {
    //   return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    // }

    // Extract order ID from merchant_uid (format: order_12345_timestamp)
    const orderIdMatch = merchant_uid.match(/order_(\d+)_/);
    if (!orderIdMatch) {
      console.error('[Payment Webhook] Invalid merchant_uid format:', merchant_uid);
      return NextResponse.json({ error: 'Invalid merchant_uid' }, { status: 400 });
    }

    const orderId = parseInt(orderIdMatch[1]);

    // Update WooCommerce order status based on payment status
    let newStatus = 'pending';
    if (status === 'paid' || status === 'ready') {
      newStatus = 'processing'; // Payment successful, order being processed
    } else if (status === 'failed' || status === 'cancelled') {
      newStatus = 'failed'; // Payment failed
    }

    // TODO: Call WooCommerce API to update order status
    // await updateOrderStatus(orderId, newStatus);

    console.log(`[Payment Webhook] Updated order ${orderId} to ${newStatus}`);

    return NextResponse.json({
      success: true,
      orderId,
      status: newStatus
    });
  } catch (error: any) {
    console.error('[Payment Webhook] Error:', error);

    return NextResponse.json(
      { error: 'Webhook processing failed', details: error.message },
      { status: 500 }
    );
  }
}
```

Key decisions:
- Webhook signature verification deferred (security TODO)
- Order ID extracted from `merchant_uid` pattern
- Status mapping: 'paid'→'processing', 'failed'→'failed'
- WooCommerce order update placeholder (needs updateOrderStatus function)

Verification: Webhook endpoint responds 200 OK to PortOne callbacks
</task>

## Verification Criteria

**Functional:**
- [ ] Submitting checkout form opens PortOne payment window
- [ ] Payment window shows correct order amount
- [ ] Test payment succeeds (use PortOne test credentials)
- [ ] Successful payment redirects to /order-complete
- [ ] Failed payment shows error message in drawer
- [ ] Cart cleared after successful payment
- [ ] Webhook receives PortOne callback

**Technical:**
- [ ] PortOne SDK initialized with store ID and channel key
- [ ] Payment initiation creates unique paymentId
- [ ] Environment variables configured in .env.local
- [ ] TypeScript compilation passes
- [ ] Console logs show payment flow steps
- [ ] Webhook extracts order ID from merchant_uid

**UX:**
- [ ] Loading state during payment initiation
- [ ] Error messages user-friendly
- [ ] Payment window mobile-responsive
- [ ] Drawer closes on payment success

## Must-Haves (Phase Goal: Payment Submits)

- **Payment initiated**: PortOne payment window opens with correct amount
- **Payment processes**: Test payment succeeds and redirects to confirmation
- **Order updated**: Webhook receives callback and logs status change

## Notes

- **Security TODO:** Implement webhook signature verification before production
- **WooCommerce Update TODO:** Complete updateOrderStatus() in lib/woocommerce.ts
- Test credentials: PortOne provides sandbox mode for testing
- Customer must provide production credentials before live deployment
- Plan 04 will create /order-complete page for confirmation display
